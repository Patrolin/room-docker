<!DOCTYPE html>
<head>
  <script src="shared/qPact.js"></script>
  <script src="shared/black-magic.js"></script>
  <script src="shared/http.js"></script>
  <style>
    body {
      margin: 0;
    }
    body > * {
      width: 100%;
    }
    output {
      white-space: pre;
    }
    button[addgroup], button[adduser] {
      color: #aaaaaa;
    }
  </style>
  <script>
    class MessageInputComponent extends InputComponent {
      load() {
        this.history = [''];
        this.historyIndex = 0;
      }
      oninput(ev) {
        this.render();
      }
      onkeydown(ev) {
        switch (ev.key) {
          case 'Enter':
            if (this.e.value) {
              this.history[this.history.length - 1] = this.e.value;
              this.historyIndex = this.history.length;
              this.history.push('');
              this.alter();
            }
            break;
          case 'ArrowUp':
            ev.preventDefault();
            var prevHistoryIndex = this.historyIndex;
            if (prevHistoryIndex === this.history.length - 1)
              this.history[this.history.length - 1] = this.e.value;
            this.historyIndex = Math.max(0, this.historyIndex - 1);
            if (this.historyIndex !== prevHistoryIndex) {
              this.e.value = this.history[this.historyIndex];
            }
            break;
          case 'ArrowDown':
            ev.preventDefault();
            var prevHistoryIndex = this.historyIndex;
            this.historyIndex = Math.min(this.historyIndex + 1, this.history.length - 1);
            if (this.historyIndex !== prevHistoryIndex)
              this.e.value = this.history[this.historyIndex];
            break;
        }
      }
      clearMessage() {
        this.e.value = '';
      }
    }
    defineComponent('input[type="text"][msg]', MessageInputComponent);

    class App extends Component {
      initSocket(s) {
        this.s = new WebSocket(`ws://${location.host}/chat`);
        for (var k of this.constructor.socketEvents)
          this.s.addEventListener(k, this[`at${k}`].bind(this));
      }
      load() {
        this.initSocket();
        this.channel = null;

        this.content = this.e.q(/[content]/);
        this.overlay = this.e.q(/[overlay]/);
        this.adduser = this.e.q(/div[adduser]/);
        this.channels = this.content.q(/div[channels]/);
        this.users = this.content.q(/div[users]/);
        this.innercontent = this.content.q(/div[innercontent]/);
        this.adduserButton = this.users.q(/button[adduser]/);
        this.adduserInput = this.adduser.q(/input[adduser]/);
        this.adduserSelect = this.adduser.q(/div[adduser]/);
        this.output = this.e.q(/.output/);
        this.input = this.e.q(/input[msg]/);

        this.overlayOutput = this.overlay.q(/output/);
      }

      onalter(ev) {
        switch (ev.srcElement) {
          case this.input:
            this.sendMessage(this.input.value);
            this.input.value = '';
            break;
          case this.adduserButton:
            this.adduser.c.disabled = false;
            this.adduser.q(/input/).focus();
            this.render();
            break;
          case this.adduserSelect:
            this.adduser.c.disabled = true;
            this.adduser.q(/input/).blur();
            this.render();
            break;
          case this.adduserInput:
            this.s.send(`{"type": "searchUsers", "msg": "${this.adduserInput.value}"}`);
            break;
          default:
            if (ev.srcElement.matches('button[channel]')) {
              if (this.channel !== null) this.channel.removeAttribute('bold');
              this.channel = ev.srcElement;
              this.channel.setAttribute('bold', '');
              this.innercontent.c.disabled = false;
              this.render();
            } else if (ev.srcElement.matches('button[adduser]')) {
              this.s.send(`{"type": "join", "msg": ${ev.srcElement.uuid}}`);
            }
        }
      }

      atopen(ev) {
        this.content.removeAttribute('blur');
        this.overlay.setAttribute('disabled', '');
        this.s.send('{"type": "hello"}');
      }
      atclose(ev) {
        this.content.setAttribute('blur', '');
        this.overlay.removeAttribute('disabled');
        this.overlayOutput.value = 'Connection lost';
        this.overlay.parentNode.c.render();
        setTimeout(this.initSocket.bind(this), 5000);
      }
      aterror(ev) {
        console.log(ev);
      }

      atmessage(ev) {
        var out = JSON.parse(ev.data);
        console.log(out);
        switch (out.type) {
          case 'hello':
            this.channels.Q();
            for (var uuid in out.msg) {
              var x = out.msg[uuid];
              if (x.table === 0) {
                this.channels.q(`<button channel>${x.name}`).uuid = uuid;
              }
            }
            pactInit(this.channels);
            this.channels.c.render();

            this.users.Q();
            for (var uuid in out.msg) {
              var x = out.msg[uuid];
              if (x.table === 1) {
                this.users.q(`<button channel>${x.name}`).uuid = uuid;
              }
            }
            this.adduserButton = this.users.q('<button adduser>+');
            pactInit(this.users);
            this.users.c.render();
            break;
          case 'searchUsers':
            this.adduserSelect.Q();
            for(var x of out.msg){
              this.adduserSelect.q(`<button adduser>${x.name}`).uuid = x.uuid;
            }
            pactInit(this.adduserSelect);
            this.adduserSelect.c.render();
            break;
          // TODO(Patrolin): implement status
          case 'msg':
            // TODO(Patrolin): receive messages
            //for (var line of ev.data.split('\n')) this.drawMessage(line);
            //this.output.c.render();
            //this.output.c.scroll = this.output.c.scrollMax;
            break;
          default:
          //console.log(out);
        }
      }
      drawMessage(value) {
        if (value) {
          var e = q(value);
          var d = e.constructor === Text ? q('<text>') : q('<p>');
          d.q(e);
          this.output.append(d);
          pactInit(d);
        }
      }
      sendMessage(value) {
        if(this.channel === null) {
          this.input.value = value;
          return;
        }
        this.drawMessage(value);
        this.output.value += `${value}\n`;
        this.output.c.render();
        this.output.c.scroll = this.output.c.scrollMax;

        this.s.send(
          `{"type": "msg", "B": ${this.channel.uuid}, "msg": "${value}"}`
        );
      }
    }
    App.socketEvents = getEvents(App, 'at');
    defineComponent('app', App);
  </script>
</head>
<body id="body">
  <app>
    <stack>
      <row content blur>
        <div channels f="0.1" width="79" cHeight="64" nopadding>
          <!--<button addGroup>+</button>-->
        </div>
        <div users f="0.1" width="79" cHeight="64" nopadding>
          <button adduser>+</button>
        </div>
        <div innercontent nopadding disabled>
          <div class="output" cHeight="32"></div>
          <input f="0.1" type="text" msg placeholder="Send a message!" />
        </div>
      </row>
      <div overlay padding>
        <output>Connecting<br />to server</output>
      </div>
      <div adduser nopadding disabled>
        <input adduser f="0.1" placeholder="Add a user!" />
        <div adduser cHeight="32" onclick="this.c.alter()">
      </div>
    </stack>
  </app>
</body>
